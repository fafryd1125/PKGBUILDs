diff --git a/configure.ac b/configure.ac
index f477c21..293a1f4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -19,9 +19,9 @@ AC_PROG_CXX
 AC_PROG_LIBTOOL
 
 # Checks for dependencies.
-PKG_CHECK_MODULES(X11, x11)
-AC_SUBST(X11_CFLAGS)
-AC_SUBST(X11_LIBS)
+#PKG_CHECK_MODULES(X11, x11)
+#AC_SUBST(X11_CFLAGS)
+#AC_SUBST(X11_LIBS)
 
 # Check for optional dependencies.
 AC_ARG_ENABLE(dri2, AS_HELP_STRING([--disable-dri2], [Disable driver name query through DRI2 (default: auto)]), [DRI2=$enableval], [DRI2=auto])
@@ -32,6 +32,9 @@ case "$DRI2,$HAVE_DRI2PROTO" in
         ;;
     yes,yes | auto,yes)
         AC_DEFINE(DRI2, 1, [Request driver name from DRI2])
+	PKG_CHECK_MODULES(X11, x11)
+	AC_SUBST(X11_CFLAGS)
+	AC_SUBST(X11_LIBS)
         DRI2=yes
         PKG_CHECK_MODULES(XEXT, xext)
         AC_SUBST([XEXT_CFLAGS])
diff --git a/include/vdpau/vdpau.h b/include/vdpau/vdpau.h
index 0bc5b60..1d63bb1 100644
--- a/include/vdpau/vdpau.h
+++ b/include/vdpau/vdpau.h
@@ -452,6 +452,18 @@
  * - Multiple bitstream buffer array entries (e.g. one per slice) may point at
  *   the same physical data storage for the slice start code prefix.
  *
+ * \subsection bitstream_vp8 VP8
+ *
+ * Include exactly one VP8 frame. The bitstream passed to VDPAU should contain
+ * a complete VP8 frame, starting with the uncompressed frame header. No start
+ * code needs to be added.
+ *
+ * Note that if desired:
+ *
+ * - The start code 0x9D012A, which is usually only part of the key frame
+ *   uncompressed header, may be included in a separate bitstream buffer array
+ *   entry to the actual frame data extracted from the bitstream.
+ *
  * \section video_mixer_usage Video Mixer Usage
  *
  * \subsection video_surface_content VdpVideoSurface Content
@@ -2484,6 +2496,14 @@ typedef uint32_t VdpDecoderProfile;
 /** \brief Support for 8 bit depth only */
 #define VDP_DECODER_PROFILE_H264_HIGH_444_PREDICTIVE    ((VdpDecoderProfile)26)
 /** \hideinitializer */
+#define VDP_DECODER_PROFILE_DIVX3_QMOBILE               ((VdpDecoderProfile)27)
+/** \hideinitializer */
+#define VDP_DECODER_PROFILE_DIVX3_MOBILE                ((VdpDecoderProfile)28)
+/** \hideinitializer */
+#define VDP_DECODER_PROFILE_DIVX3_HOME_THEATER          ((VdpDecoderProfile)29)
+/** \hideinitializer */
+#define VDP_DECODER_PROFILE_DIVX3_HD_1080P              ((VdpDecoderProfile)30)
+/** \hideinitializer */
 /** \brief MPEG-H Part 2 == H.265 == HEVC */
 #define VDP_DECODER_PROFILE_HEVC_MAIN                   ((VdpDecoderProfile)100)
 /** \hideinitializer */
@@ -2494,6 +2514,14 @@ typedef uint32_t VdpDecoderProfile;
 #define VDP_DECODER_PROFILE_HEVC_MAIN_12                ((VdpDecoderProfile)103)
 /** \hideinitializer */
 #define VDP_DECODER_PROFILE_HEVC_MAIN_444               ((VdpDecoderProfile)104)
+/** \hideinitializer */
+#define VDP_DECODER_PROFILE_VP8_V0                      (VdpDecoderProfile)110
+/** \hideinitializer */
+#define VDP_DECODER_PROFILE_VP8_V1                      (VdpDecoderProfile)111
+/** \hideinitializer */
+#define VDP_DECODER_PROFILE_VP8_V2                      (VdpDecoderProfile)112
+/** \hideinitializer */
+#define VDP_DECODER_PROFILE_VP8_V3                      (VdpDecoderProfile)113
 
 /** \hideinitializer */
 #define VDP_DECODER_LEVEL_MPEG1_NA 0
@@ -2588,6 +2616,9 @@ typedef uint32_t VdpDecoderProfile;
 /** \hideinitializer */
 #define VDP_DECODER_LEVEL_DIVX_NA 0
 
+/** \hideinitializer */
+#define VDP_DECODER_LEVEL_VP8_NA 0
+
 /**
  * The VDPAU H.265/HEVC decoder levels correspond to the values of
  * general_level_idc as described in the H.265 Specification, Annex A,
@@ -3299,6 +3330,56 @@ typedef struct {
     uint8_t RefPicSetLtCurr[8];
 } VdpPictureInfoHEVC;
 
+/*
+ * \brief Picture parameter information for a VP8 picture.
+ *
+ * Based on RFC 6386 "VP8 Data Format and Decoding Guide" section 9 "Frame
+ * Header" and Annex A "Bitstream Syntax".
+ * The RFC 6386 is available at http://datatracker.ietf.org/doc/rfc6386/.
+ *
+ * Note: References to "copy of bitstream field" in the field descriptions
+ * may refer to data literally parsed from the bitstream, or derived from
+ * the bitstream using a mechanism described in the specification.
+ */
+typedef struct {
+    /** Copy of the VP8 bitstream field. */
+    VdpBool key_frame;
+    /** Copy of the VP8 bitstream field. */
+    uint8_t version;
+    /** Copy of the VP8 bitstream field. */
+    VdpBool show_frame;
+    /** Copy of the VP8 bitstream field. */
+    uint32_t first_part_size;
+
+    /** Copy of the VP8 bitstream field. Key Frames-only. */
+    uint8_t horizontal_scale;
+    /** Copy of the VP8 bitstream field. Key Frames-only. */
+    uint16_t width;
+    /** Copy of the VP8 bitstream field. Key Frames-only. */
+    uint8_t vertical_scale;
+    /** Copy of the VP8 bitstream field. Key Frames-only. */
+    uint16_t height;
+
+    /**
+     * One frame worth of decompressed data from the arbitrarily distant past.
+     * Set to VDP_INVALID_HANDLE when not used.
+     */
+    VdpVideoSurface golden_frame;
+
+    /**
+     * Alternate reference frames are decoded normally but most of the time only
+     * used as reference for other frames and not shown to the user.
+     * Set to VDP_INVALID_HANDLE when not used.
+     */
+    VdpVideoSurface altref_frame;
+
+    /**
+     * The immediately previous frame can always be used as reference.
+     * Set to VDP_INVALID_HANDLE when not used.
+     */
+    VdpVideoSurface previous_frame;
+} VdpPictureInfoVP8;
+
 /**
  * \brief Decode a compressed field/frame and render the result
  *        into a \ref VdpVideoSurface "VdpVideoSurface".
diff --git a/include/vdpau/vdpau_x11.h b/include/vdpau/vdpau_x11.h
index edbc275..c10d12d 100644
--- a/include/vdpau/vdpau_x11.h
+++ b/include/vdpau/vdpau_x11.h
@@ -41,7 +41,12 @@
 #ifndef _VDPAU_X11_H
 #define _VDPAU_X11_H
 
+#if DRI2
 #include <X11/Xlib.h>
+#else
+typedef unsigned long Drawable;
+typedef void* Display;
+#endif 
 #include "vdpau.h"
 
 #ifdef __cplusplus
diff --git a/src/vdpau_wrapper.c b/src/vdpau_wrapper.c
index 79dcb94..26d2a0c 100644
--- a/src/vdpau_wrapper.c
+++ b/src/vdpau_wrapper.c
@@ -138,6 +138,15 @@ static VdpStatus _vdp_open_driver(
         snprintf(vdpau_driver_lib, sizeof(vdpau_driver_lib),
                  DRIVER_LIB_FORMAT, vdpau_driver_path, vdpau_driver) <
             sizeof(vdpau_driver_lib)) {
+        fprintf(stderr, "Failed to construct driver path: path too long\n");
+#if DRI2
+        if (vdpau_driver_dri2) {
+            XFree(vdpau_driver_dri2);
+            vdpau_driver_dri2 = NULL;
+        }
+#endif
+        _VDP_ERROR_BREAKPOINT();
+        return VDP_STATUS_NO_IMPLEMENTATION;
         _vdp_driver_dll = dlopen(vdpau_driver_lib, RTLD_NOW | RTLD_GLOBAL);
     }
 
@@ -148,10 +157,12 @@ static VdpStatus _vdp_open_driver(
                      DRIVER_LIB_FORMAT, VDPAU_MODULEDIR, vdpau_driver) >=
                 sizeof(vdpau_driver_lib)) {
             fprintf(stderr, "Failed to construct driver path: path too long\n");
+#if DRI2
             if (vdpau_driver_dri2) {
                 XFree(vdpau_driver_dri2);
                 vdpau_driver_dri2 = NULL;
             }
+#endif
             _VDP_ERROR_BREAKPOINT();
             return VDP_STATUS_NO_IMPLEMENTATION;
         }
@@ -168,10 +179,12 @@ static VdpStatus _vdp_open_driver(
         _vdp_driver_dll = dlopen(vdpau_driver_lib, RTLD_NOW | RTLD_GLOBAL);
     }
 
+#if DRI2
     if (vdpau_driver_dri2) {
         XFree(vdpau_driver_dri2);
         vdpau_driver_dri2 = NULL;
     }
+#endif
 
     if (!_vdp_driver_dll) {
         fprintf(stderr, "Failed to open VDPAU backend %s\n", dlerror());
diff --git a/trace/vdpau_trace.cpp b/trace/vdpau_trace.cpp
index 11e227c..58a2b8d 100644
--- a/trace/vdpau_trace.cpp
+++ b/trace/vdpau_trace.cpp
@@ -453,16 +453,16 @@ static void _vdp_cap_dump_picture_info(
                 (int32_t)picture_info_mpeg4->trb[0],
                 (int32_t)picture_info_mpeg4->trb[1],
                 (uint32_t)picture_info_mpeg4->vop_time_increment_resolution,
-                (uint32_t)picture_info_mpeg4->vop_coding_type,
+                (uint32_t)picture_info_mpeg4->vop_coding_type, 
                 (uint32_t)picture_info_mpeg4->vop_fcode_forward,
                 (uint32_t)picture_info_mpeg4->vop_fcode_backward,
                 (uint32_t)picture_info_mpeg4->resync_marker_disable,
-                (uint32_t)picture_info_mpeg4->interlaced,
-                (uint32_t)picture_info_mpeg4->quant_type,
-                (uint32_t)picture_info_mpeg4->quarter_sample,
-                (uint32_t)picture_info_mpeg4->short_video_header,
+                (uint32_t)picture_info_mpeg4->interlaced, 
+                (uint32_t)picture_info_mpeg4->quant_type,   
+                (uint32_t)picture_info_mpeg4->quarter_sample, 
+                (uint32_t)picture_info_mpeg4->short_video_header, 
                 (uint32_t)picture_info_mpeg4->rounding_control,
-                (uint32_t)picture_info_mpeg4->alternate_vertical_scan_flag,
+                (uint32_t)picture_info_mpeg4->alternate_vertical_scan_flag, 
                 (uint32_t)picture_info_mpeg4->top_field_first
             );
             for (uint32_t i = 0; i < _VDP_TRACE_ARSIZE(picture_info_mpeg4->intra_quantizer_matrix); ++i) {
